import turtleimport timefrom random import randint, choiceBOX_SIZE = (50, 30)DIAMOND_SIZE = 35screen = turtle.Screen()dim = (600, 400)screen.setup(dim[0] + 4, dim[1] + 8)screen.setworldcoordinates(0, 0, dim[0], dim[1])screen.bgcolor("white")screen.tracer(0)font = ("Arial", 12, "bold")block_color = "black"class Condition:    EQUAL = 0    GREATER_THAN = 1    LESS_THAN = 2    MAX = 2    @classmethod    def get_text(cls, enum, a):        if enum == cls.EQUAL:            return "n == {}".format(a)        elif enum == cls.GREATER_THAN:            return "n > {}".format(a)        elif enum == cls.LESS_THAN:            return "n < {}".format(a)    @classmethod    def get_bool(cls, enum, n, a):        if enum == cls.EQUAL:            return n == a        elif enum == cls.GREATER_THAN:            return n > a        elif enum == cls.LESS_THAN:            return n < aARROW_WIDTH = 30class Tutorial:    def __init__(self):        self.isDrawing = False        self.tut = turtle.Turtle()        self.tut.up()        self.tut.pencolor("black")        self.tut.hideturtle()        self.page = 1        self.continue_box = ResultBox(            (screen.window_width() - 100, 20), (80,35), "Continue", "purple", self.tut)                def draw_text1(self):        global screen, font        self.tut.goto(20, screen.window_height() - 40)        self.tut.seth(270)        text = [            "This is an animation mini game about Control Flow.",            "Normally, programs run one line of code after the other.",            "To have more control over what lines of code we run, we change that flow.",            "That is what is called Control Flow.",        ]        for t in text:            self.tut.write(t, align="left", font=font)            self.tut.forward(font[1] + 20)        self.tut.color("blue")        text = [                    "Code looks something like this:            And if we put it in a diagram:",            "if firstName is \"Joe\":                              (T and F being True and False)",            "           Hi Joe!",            "else if firstName is \"Mason\":",            "           Hi Mason!",            "else:",            "           Hi Person!",        ]        for t in text:            self.tut.write(t, align="left", font=font)            self.tut.forward(font[1] + 20)                    def draw_diagram1(self):        center = (screen.window_width() / 2 + 120, screen.window_height() / 2 - 40)        DIAMOND_S = 30        BOX_S = (80,30)        dia = Diamond(center, DIAMOND_S, "Joe", False, self.tut)        dia.left = ResultBox(            (center[0] - 60, center[1] - 40), BOX_S, "Hi Joe", "red", self.tut)                right_dia = Diamond((center[0] + 60, center[1] - 40), DIAMOND_S, "Mason", False, self.tut)        center = right_dia.center        right_dia.left = ResultBox(            (center[0] - 60, center[1] - 40), BOX_S, "Hi Mason", "blue", self.tut)        right_dia.right = ResultBox(            (center[0] + 60, center[1] - 40), BOX_S, "Hi Person", "orange", self.tut)        dia.right = right_dia        dia.draw_connectors()        dia.draw_shape()        dia.draw_text()        def draw_text2(self):        global screen, font        left = 20        self.tut.goto(left, screen.window_height() - 40)        self.tut.seth(270)        self.tut.color("black")        text = [            "We can control the flow using true or false statements",            "If another number is greater than another:",            ("1 > 0 | True,  ", "green", False), ("  3 > 5 | False, ", "red", False), ("   3 > 3 | False", "red", True),            "a number is less than another:",             ("5 < 10 | True, ", "green", False), ("  8 < 3 | False", "red", True),            "A number is equal to another (== means is equal):",             ("1 == 1 | True, ", "green", False), ("  5 == 3 | False", "red", True),        ]        self.write_arb_text(text)        text = [            "Having a statement like \"1 > 0\" isn't very helpful, since it doesn't change",            ("Because of that we say let", "black", False), ("    `n` = 1      ", "blue", False), ". Now we can compare n:",            ("n > 0 | True,   ", "green", False), ("n < 0 | False", "red", True),            "We can even change `n` to other numbers as needed",        ]        self.write_arb_text(text)    def draw_text3(self):        global screen, font        left = 20        self.tut.goto(left, screen.window_height() - 40)        self.tut.seth(270)        self.tut.color("black")        text = [                        ("In the mini game, you see ", "black", False), ("  \"n = \"   ", "blue", False), " a number.",            "You'll also see a flow chart with comparisons on it.",            "Whether the comparison to n is true or false, it will left or right respectively",            "You have to figure out which box it will end up in: ",            ("A,  ", "red", False), ("B,  ", "blue", False), ("or  ", "black", False), ("C", "orange", True),            "When you think you've found the correct one, click the box.",            "Once you've picked your anwser, a turtle will show ",            "the flow the program would take",            ("Have fun!", "green", True)        ]        self.write_arb_text(text)    def write_arb_text(self, text):        left = 20        for t in text:            if isinstance(t, str):                self.tut.color("black")                                self.tut.write(t, align="left", font=font)                self.tut.forward(font[1] + 20)                self.tut.setx(left)            else:                print(t)                self.tut.color(t[1])                self.tut.write(t[0], move=True, align="left", font=font)                if t[2]:                    self.tut.forward(font[1] + 20)                    self.tut.setx(left)            def draw_continue(self):        self.continue_box.draw_shape()        self.continue_box.draw_text()        def start(self):        global state, game, screen        self.isDrawing = True        screen.tracer(0)        if self.page == 1:            self.draw_text1()            self.draw_diagram1()                    elif self.page == 2:            self.draw_text2()        elif self.page == 3:            self.draw_text3()                    else:            state = game            state.start()            return                self.draw_continue()        screen.tracer(1)        self.isDrawing = False        def reset(self):        self.tut.clear()        self.start()        def click(self, x,y):        if self.continue_box.is_clicked(x,y):            print("continue!")            self.page += 1            self.reset()class Game:    def __init__(self):        self.isActive = False        self.edna = turtle.Turtle()        self.flow_turtle = turtle.Turtle()        self.code_turtle = turtle.Turtle()        self.setup_turtles()            def setup_turtles(self):        self.edna.hideturtle()        self.edna.home()        self.flow_turtle.color("yellow")        self.flow_turtle.shape("turtle")        self.flow_turtle.speed(2)        self.flow_turtle.hideturtle()        self.code_turtle.color("purple")        self.code_turtle.shape("turtle")        self.code_turtle.speed(2)        self.code_turtle.hideturtle()    def setup_dividers(self):        self.divider = (2 * dim[0]/3, dim[1]/2)        self.mid_div = (self.divider[0]/2, self.divider[1])        self.left_div = Box(0, dim[1], self.divider[0], 0, self.edna)        self.right_div = Box(self.divider[0], dim[1], dim[0], 0, self.edna)        self.edna.color("black")        self.left_div.draw_shape()        self.right_div.draw_shape()    def start(self):        self.setup_dividers()        self.randomize()        self.setup_code()        self.info_box.draw_shape()        self.top_dia.draw_shape()        screen.tracer(1)        self.isActive = True    def setup_code(self):        global font        print("Drawing code")        self.code_turtle.hideturtle()        ifs = []        ifs.append("if " + self.top_dia.text)        ifs.append("else if " + self.top_dia.right.text)        ifs.append("else")        self.code_turtle.up()        self.code_turtle.color("black")        self.code_turtle.goto(self.right_div.left + 20,                              self.right_div.top - 30)        self.code_turtle.write("Code: ", False, align="left", font=font)        self.code_turtle.sety(self.code_turtle.ycor() - 30)        self.code_start_y = self.code_turtle.ycor() + 20        i = 0        colors = ["red", "blue", "orange"]        self.code_height = 95        for iffy in ifs:            # print("Writing iffy")            self.code_turtle.write(iffy, False, align="left", font=font)            self.code_turtle.begin_fill()            self.code_turtle.color(colors[i])            self.code_turtle.setx(self.right_div.right)            self.code_turtle.sety(self.code_turtle.ycor() - 50)            self.code_turtle.setx(self.right_div.left + 20)            self.code_turtle.end_fill()            self.code_turtle.sety(self.code_turtle.ycor() - 50)            self.code_turtle.color("black")            i += 1    def randomize(self):        n = randint(-5, 5)        a = randint(-5, 5)        b = randint(-5, 5)        cond_a = randint(0, Condition.MAX)        self.top_dia = Diamond(self.mid_div, DIAMOND_SIZE, Condition.get_text(            cond_a, a), Condition.get_bool(cond_a, n, a), self.edna)        self.top_dia.add_left_box(BOX_SIZE, "A", "red")        cond_b = randint(0, Condition.MAX)        self.top_dia.add_right_dia(DIAMOND_SIZE, Condition.get_text(            cond_b, b), Condition.get_bool(cond_b, n, b))        self.top_dia.right.add_left_box(BOX_SIZE, "B", "blue")        self.top_dia.right.add_right_box(BOX_SIZE, "C", "orange")        self.info_box = ResultBox(            (self.mid_div[0], dim[1] - 100), BOX_SIZE, "n = {}".format(n), "gray", self.edna)        self.n = n        self.a = a        self.b = b    def reset(self):        global screen        screen.tracer(0)        self.code_turtle.clear()        self.flow_turtle.clear()        self.edna.clear()        time.sleep(0.1)        self.start()                screen.tracer(1)    def get_clicked(self, x, y):        res_boxes = self.top_dia.ret_boxes()        for res_box in res_boxes:            if res_box.box.is_clicked(x, y):                return res_box        return None    def correct(self):        return self.top_dia.seek()    def on_guess(self, isCorrect):        global screen, font        screen.tracer(1)        self.edna.setx(self.info_box.center[0])        self.edna.sety(self.info_box.center[1] - 40)        if isCorrect:            self.edna.color("green")            self.edna.write("correct", False, align="center", font=font)        else:            self.edna.color("red")            self.edna.write("incorrect", False, align="center", font=font)        self.show_flow()        screen.tracer(0)        self.reset()        screen.tracer(1)    def move_turtles(self, side_dist, h_dist):        self.code_turtle.forward(self.code_height)        self.flow_turtle.forward(side_dist)        self.flow_turtle.seth(270)  # face down        self.flow_turtle.forward(h_dist)    def show_flow(self):        global font        # Turn off animations        screen.tracer(0)        # Send flow turtle to top diamond        self.flow_turtle.up()        self.flow_turtle.goto(self.top_dia.center)        # Send code turtle to top of code        self.code_turtle.up()        self.code_turtle.goto(self.right_div.left + 10, self.code_start_y)        # Point code turtle down        self.code_turtle.seth(270)        # Set properties of code turtle        self.code_turtle.speed(2)        self.code_turtle.color("purple")        self.code_turtle.showturtle()        self.code_turtle.up()        self.flow_turtle.down()        self.flow_turtle.speed(2)        # Start showing animations        screen.tracer(1)        side_dist = abs(self.top_dia.center[0] - self.top_dia.left.center[0])        h_dist = abs(self.top_dia.center[1] - self.top_dia.left.center[1])        self.flow_turtle.showturtle()        # if self.top_dia.isTrue:        #     self.flow_turtle.color("green")        #     self.flow_turtle.setheading(0) # face right        #     self.move_turtles(side_dist, h_dist)        # else:        #     self.flow_turtle.color("red")        #     self.code_turtle.down()        #     self.flow_turtle.setheading(180) # face left        #     self.move_turtles(side_dist, h_dist)        res = self.top_dia        while not isinstance(res, ResultBox):            side_dist = abs(res.center[0] - res.left.center[0])            h_dist = abs(res.center[1] - res.left.center[1])            if res.isTrue:                self.flow_turtle.color("green")                self.code_turtle.down()                self.flow_turtle.setheading(180)  # face left                self.move_turtles(side_dist, h_dist)                res = res.left            else:                self.flow_turtle.color("red")                self.flow_turtle.setheading(0)  # face right                self.move_turtles(side_dist, h_dist)                res = res.right                # If final result is the false box, move code turtle again                if isinstance(res, ResultBox):                    self.code_turtle.down()                    self.code_turtle.forward(self.code_height)        # Circle correct code block        self.code_turtle.seth(0)        dist = self.right_div.right - self.right_div.left - 10        self.code_turtle.forward(dist)        self.code_turtle.left(90)        self.code_turtle.forward(self.code_height)        self.code_turtle.left(90)        self.code_turtle.forward(dist)        self.code_turtle.up()        pos = self.code_turtle.pos()        self.code_turtle.goto(pos[0] + 10, pos[1] - self.code_height * 2/3)        # In colored box, display message        self.code_turtle.pencolor("white")        self.code_turtle.write("This code will be run",                               False, align="left", font=font)        self.flow_turtle.hideturtle()        # Wait 2s before reseting game        time.sleep(2)class Drawable:    def __init__(self, center, size, text, edna):        self.center = center        self.text = text        self.edna = edna        if isinstance(size, tuple):            self.box = Box(center[0] - size[0]/2, center[1] + size[1]/2,                           center[0] + size[0]/2, center[1] - size[1]/2, self.edna)        else:            self.box = Box(center[0] - size/2, center[1] + size/2,                           center[0] + size/2, center[1] - size/2, self.edna)    def draw_text(self):        global font        self.edna.color("white")        self.edna.up()        self.edna.setpos(self.center)        self.edna.sety(self.center[1] - font[1])        # print(edna.pos())        self.edna.write(self.text, False, align="center", font=font)    def is_clicked(self, x, y):        return self.box.is_clicked(x, y)class Diamond(Drawable):    def __init__(self, center, size, text, isTrue, edna):        super().__init__(center, size, text, edna)        self.center = center        self.text = text        self.size = size        self.isTrue = isTrue        self.left = None        self.right = None    def draw_shape(self):        self.draw_connectors()        self.edna.fillcolor("black")        self.edna.begin_fill()        x, y = self.center        left = (x - self.size, y)        right = (x + self.size, y)        top = (x, y + self.size)        bottom = (x, y - self.size)        self.edna.up()        # Trinket does not correctly penup        self.edna.pencolor("white")        self.edna.goto(left)        self.edna.down()        self.edna.setpos(top)        self.edna.setpos(right)        self.edna.setpos(bottom)        self.edna.setpos(left)        self.edna.end_fill()        self.edna.up()        if self.right is not None:            self.right.draw_shape()        if self.left is not None:            self.left.draw_shape()        self.draw_text()    def set_right(self, right):        self.right = right    def set_left(self, left):        self.left = left    def add_left_box(self, size, text, color):        pos = (self.center[0] / 3 * 2, self.center[1] / 3 * 2)        self.left = ResultBox(pos, size, text, color, self.edna)    def add_right_box(self, size, text, color):        pos = (self.center[0] / 3 * 4, self.center[1] / 3 * 2)        self.right = ResultBox(pos, size, text, color, self.edna)    def add_right_dia(self, size, text, boo):        pos = (self.center[0] / 3 * 4, self.center[1] / 3 * 2)        self.right = Diamond(pos, size, text, boo, self.edna)    def add_left_dia(self, size, text, boo):        pos = (self.center[0] / 3 * 2, self.center[1] / 3 * 2)        self.left = Diamond(pos, size, text, boo, self.edna)    def draw_connectors(self):        self.edna.pensize(3)        if self.right is not None:            self.edna.color("red")            obj = self.right            self.edna.up()            self.edna.goto(self.center)            self.edna.down()            self.edna.setx(obj.center[0])            self.edna.sety(obj.center[1])            self.edna.up()            # Write True/False text            self.edna.sety(self.center[1] + 10)            self.edna.setx(self.center[0] + 20)            self.edna.color("red")            self.edna.write("F", False, align="left", font=font)        if self.left is not None:            self.edna.color("green")            obj = self.left            self.edna.up()            self.edna.goto(self.center)            self.edna.down()            self.edna.setx(obj.center[0])            self.edna.sety(obj.center[1])            self.edna.up()            # Write True/False text            self.edna.sety(self.center[1] + 10)            self.edna.setx(self.center[0] - 20)            self.edna.color("green")            self.edna.write("T", False, align="right", font=font)        self.edna.pensize(1)    def seek(self):        # Find the text of the block it leads to        if self.isTrue:            return self.left.seek()        else:            return self.right.seek()    def ret_boxes(self):        li = []        if self.left is not None:            if isinstance(self.left, ResultBox):                li.append(self.left)            else:                li += self.left.ret_boxes()        if self.right is not None:            if isinstance(self.right, ResultBox):                li.append(self.right)            else:                li += self.right.ret_boxes()        return liclass Box(Drawable):    def __init__(self, left, top, right, bottom, edna):        self.top = top        self.left = left        self.bottom = bottom        self.right = right        self.edna = edna    def draw_shape(self):        self.edna.up()        self.edna.goto((self.left, self.top))        self.edna.down()        self.edna.setpos((self.right, self.top))        self.edna.setpos((self.right, self.bottom))        self.edna.setpos((self.left, self.bottom))        self.edna.setpos((self.left, self.top))        self.edna.up()    def is_clicked(self, x, y):        if self.left <= x <= self.right and self.bottom <= y <= self.top:            return True        return False    def __repr__(self):        return "left top: ({}, {}), right bottom: ({}, {})".format(self.left, self.top, self.right, self.bottom)class ResultBox(Drawable):    def __init__(self, center, w_h_size, text, color, edna):        super().__init__(center, w_h_size, text, edna)        self.center = center        self.color = color        self.text = text    def draw_shape(self):        self.edna.fillcolor(self.color)        self.edna.begin_fill()        self.box.draw_shape()        self.edna.end_fill()        self.draw_text()    def seek(self):        return self.textdef get_clicked(x, y):    global gamedef game_click(x, y):    global state    game = state    if not game.isActive:        return    game.isActive = False    answer = game.correct()    guessed_box = game.get_clicked(x, y)    print(x, y)    if guessed_box is None:        game.isActive = True        return    game.on_guess(guessed_box.text == answer)    game.isActive = Truedef tut_click(x,y):    global state    tut = state    if tut.isDrawing:        return    tut.click(x,y)def onclick(x, y):    global state    if isinstance(state, Game):        game_click(x, y)    elif isinstance(state, Tutorial):        tut_click(x,y)# self.edna.speed(1)tut = Tutorial()tut.start()game = Game()# game.start()state = tutscreen.tracer(1)screen.onclick(onclick)screen.mainloop()